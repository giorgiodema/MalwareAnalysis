import os
from tqdm import tqdm
from functools import reduce
from scipy import sparse
import random
import numpy as np
from sklearn.svm import LinearSVC
import pickle
import BayesClassifier
import sys

TRAINING_SIZE = 0.66

class MalwareDetector:


    def __init__(self,trainingSetSize):
        self.malwaresWithFamilies = None                        # <sha-256:family_name>
        self.programsWithFeatures = None                        # <sha-256:[list of features]>
        self.allFeatures = None                                 # <feature:idx>
        self.clf = LinearSVC(random_state=0, tol=1e-5,max_iter=100000)          
        self.programs = None                                    # [sha1,sha2,...] 
        self.trainingSize = trainingSetSize
        self.fitted = False

        self.k = 1000
        self.mostWeigthedFeatures = {}      

    def loadDatabase(self):
        
        self.malwaresWithFamilies = {}
        print("\MalwareDetector:::Loading malwares:")
        familyFile = open(".\drebin\sha256_family.csv","r")
        familyFile.readline()

        i=0
        line = familyFile.readline()
        while line!="":
            i+=1
            line = line.strip().split(",")
            self.malwaresWithFamilies[line[0]] = line[1]
            line = familyFile.readline()
            if i%500==0:
                print(".", end=" ")
        print("\n")


        # <sha-256:[list of features]>
        self.programsWithFeatures = {}
        print("\nMalwareDetector:::Loading features:")
        files = os.listdir(".\drebin\\feature_vectors")
        for filename in tqdm(files):
            f = open('.\drebin\\feature_vectors\\'+filename,"r")
            self.programsWithFeatures[filename] = [x.strip() for x in f.readlines()]

        # indexing all features
        print("\nMalwareDetector:::Listing all features:")
        aux = list(map(lambda x:self.programsWithFeatures[x], self.programsWithFeatures))
        allFeatureslist =  [item for sublist in tqdm(aux) for item in sublist]
        allFeatureslist = list(set(allFeatureslist))                                    #removing duplicates
        self.allFeatures = {}
        print("\nMalwareDetector:::Indexing features:")
        i=0
        for x in tqdm(allFeatureslist):
            self.allFeatures[x] = i
            i+=1

        # listing all programs
        self.programs = [x for x in self.programsWithFeatures.keys()]

    def fit(self):
        if self.programs == None:
            raise Exception("ERROR: you must load database first")
        
        self.fitted = True
        print("\nMalwareDetector:::Creating training set:")
        trainingItems = self.programs[0:int(len(self.programs)*self.trainingSize)]
        X = sparse.lil_matrix((len(trainingItems),len(self.allFeatures)))
        Y = np.zeros(len(trainingItems))

        for i in tqdm(range(0,len(trainingItems))):
            if trainingItems[i] in self.malwaresWithFamilies:
                Y[i] = 1
            for f in self.programsWithFeatures[trainingItems[i]]:
                fidx = self.allFeatures[f]
                X[i,fidx] = 1

        # fitting SVM
        print("\nMalwareDetector:::Fitting...",end="")
        self.clf.fit(X,Y)
        print("Done")

        # extracting most weigthed features
        weigths = self.clf.coef_[0]

        sortedweigths = np.sort(weigths)
        sortedweigths = sortedweigths[::-1]
        higherWeigths = sortedweigths[0:self.k]

        for f in self.allFeatures:
            idx = self.allFeatures[f]
            if weigths[idx] in higherWeigths:
                self.mostWeigthedFeatures[f] = idx

    def permutePrograms(self):
        if self.programs == None:
            raise Exception("ERROR: you must load database first")
        random.shuffle(self.programs)

    def test(self):

        if self.programs == None:
            raise Exception("ERROR: you must load database first")

        if self.fitted == False:
            raise Exception("Error: you must fit detector first")

        # creating test set
        print("\nMalwareDetector:::Creating test set:")
        testItems = self.programs[int(len(self.programs)*(self.trainingSize)):]
        XTest = sparse.lil_matrix((len(testItems),len(self.allFeatures)))
        YExpected = np.zeros(len(testItems))

        for i in tqdm(range(0,len(testItems))):
            if testItems[i] in self.malwaresWithFamilies:
                YExpected[i] = 1
            for f in self.programsWithFeatures[testItems[i]]:
                fidx = self.allFeatures[f]
                XTest[i,fidx] = 1

        YComputed = self.clf.predict(XTest)
        tp = 0
        tn = 0
        fp = 0
        fn = 0

        print("\nMalwareDetectorCollecting statistics:")
        for i in tqdm(range(0,len(testItems))):
            if YExpected[i] == 1:
                if YComputed[i] ==1:
                    tp +=1
                else:
                    fn +=1
            else:
                if YComputed[i] == 0:
                    tn +=1
                else:
                    fp +=1

        precision = tp/(tp+fp)
        recall = tp/(tp+fn)
        accuracy = (tp+tn)/(tp+tn+fp+fn)
        fprate = fp/(fp+tn)

        print("\n-----------------CONFUSION MATRIX------------------")
        print("\n")
        print("-----------------LEARNED FUNCTION OUTPUT-----------")
        print("    |------------Positive--------Negative----------|")
        print("G   |                        |                     |")
        print("R   |                        |                     |")
        print("O   |   Positive     {}      |      {}             |".format(tp,fp))
        print("U   |                        |                     |")
        print("N   |   Negative     {}      |      {}             |".format(fn,tn))
        print("D   |                                              |")
        print("---------------------------------------------------")
        print("precision: {}   How many files are real malware among those I considered as malware".format(precision))
        print("recall   : {}   How many malware did I spot among those in the test set".format(recall))
        print("accuracy : {}   How may programs classified correctly among those in the test set".format(accuracy))
        print("fprate   : {}   How many programs wrongly classifyed as malware among all benign programs".format(fprate))

    def predictSingleProgram(self,features):
        x = np.zeros(shape = (len(self.allFeatures)))
        for f in features:
            x[self.allFeatures[f]] = 1

        y = self.clf.predict([x])
        y = y[0]

        if y == 0:
            return (0,None)
        
        targetFeatures = []
        for f in features:
            if f in self.mostWeigthedFeatures:
                targetFeatures.append(f)
        
        return (1,targetFeatures)



class FamilyClassifier:
    
    def __init__(self,md,trainingSetSize):
        self.md = md
        if not self.md.fitted:       
            self.md.loadDatabase()
            self.md.fit()
        self.dataset = []                # dataset = [ [family, feature1, feature2, ... featuren] ... ]
        self.families = None
        self.attributes = None
        self.MIN_FAMILIES_SAMPLES = 50
        self.familyClassifier = None

    def initializeClassifier(self):

        # delete samples of families with less than MIN_FAMILIES_SAMPLES samples
        samplesPerFamily = {}
        for s in self.md.malwaresWithFamilies.keys():
            if self.md.malwaresWithFamilies[s] in samplesPerFamily.keys():
                samplesPerFamily[self.md.malwaresWithFamilies[s]] +=1
            else:
                samplesPerFamily[self.md.malwaresWithFamilies[s]] = 1
        families = [ x for x in samplesPerFamily.keys() if samplesPerFamily[x]>=self.MIN_FAMILIES_SAMPLES]


        for sha in self.md.malwaresWithFamilies.keys():
            # make method robust against db inconsistency
            if sha not in self.md.programsWithFeatures.keys():
                continue
            sample = []
            if self.md.malwaresWithFamilies[sha] in families:
                sample.append(self.md.malwaresWithFamilies[sha])
            else:
                sample.append("UnknownFamily")
            for feature in self.md.programsWithFeatures[sha]:
                if feature in self.md.mostWeigthedFeatures:
                    sample.append(feature)
            self.dataset.append(sample)

        families.append("UnknownFamily")
        attributes = [x for x in self.md.mostWeigthedFeatures]

        self.families = families
        self.attributes = attributes

    def fitClassifier(self):
        self.familyClassifier = BayesClassifier.BinomialClassifier(self.families,self.attributes,self.dataset[0: int(self.md.trainingSize*len(self.dataset)) ])
        self.familyClassifier.Learn()
    
    def predictFamily(self,sample):
        attributes = [x for x in sample if x in self.attributes]
        return self.familyClassifier.Classify(attributes)

    def testClassifier(self):
        correct = 0
        total = 0
        print("Testing Classifier:")
        self.families.sort()
        confmatrix = {(x,y):0 for x in self.families for y in self.families}
        for sample in tqdm(self.dataset[int(self.md.trainingSize*len(self.dataset)) :]):
            ground, attributes = (sample[0],sample[1:])
            predicted = self.predictFamily(attributes)
            if predicted == ground: correct+=1
            total+=1
            confmatrix[(ground,predicted)] +=1
        print("Accuracy: {}".format(correct/total))
        print("Confusion Matrix (y-axis is ground x-axis is predicted) only elements in the first diagonal are classified right:")
        print("Families: {}".format(self.families))
        for x in self.families:
            print("{}".format(x), end="")
        print()
        for x in self.families:
            for y in self.families:
                print("{:>8}".format(confmatrix[(x,y)]), end="")
            print()
        print("--------------------------------------------------------------------------------")
                


class MalwareDetectorAndClassifier:

    def __init__(self):
        self.md = MalwareDetector(0.66)
        self.md.loadDatabase()
        self.md.fit()
        self.md.test()

        self.fc = FamilyClassifier(self.md,0.66)
        self.fc.initializeClassifier()
        self.fc.fitClassifier()
        self.fc.testClassifier()
  
    def predict(self,features):
        detection,dangerousFeatures = self.md.predictSingleProgram(features)
        if detection == 1:
            family = self.fc.predictFamily(features)
            return (True,family,dangerousFeatures)
        else:
            return (False,None,None)

    def getProgramsWithFeatures(self):
        return self.md.programsWithFeatures.copy()
    
    def getMalwaresWithFamilies(self):
        return self.md.malwaresWithFamilies.copy()
        




def main():

    mdfc = None
    if not os.path.isfile(".\mdfc.p"):
        mdfc = MalwareDetectorAndClassifier()
        pickle.dump(mdfc,open("mdfc.p", "wb"))

    else:
        f = open("mdfc.p","rb")
        mdfc = pickle.load(f)


    
    print("Number of features:{}".format(len(mdfc.md.allFeatures)))
    print("Number of programs:{}".format(len(mdfc.md.programs)))
    print("-----------------EXAMPLE-----------------------")
    programsWithFeatures = mdfc.getProgramsWithFeatures()
    malwaresWithFamilies = mdfc.getMalwaresWithFamilies()
    programs = list(programsWithFeatures.keys())
    random.shuffle(programs)
    
    for i in range(100):
        print("-------------Test n° {}--------------------".format(i))
        sha = programs[i]
        detection,family,df = mdfc.predict(programsWithFeatures[sha])
        trueDetection = True if sha in malwaresWithFamilies.keys() else False
        trueFamily = malwaresWithFamilies[sha] if trueDetection else None

        print("Detected:        {} (Expected {})".format("malware" if detection else "benign", "malware" if trueDetection else "benign"))
        if detection and trueDetection:
            print("Classified:      {}(Expected {})".format(family,trueFamily))
            print("Dangerous Features:")
            for f in df:
                print("\t\t\t\t{}".format(f))



main()
